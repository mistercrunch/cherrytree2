# CLAUDE.md - Cherrytree v2 Requirements & Design

## Project Overview

Cherrytree v2 is a CLI toolkit for Apache Superset release management that provides structured utilities for planning, tracking, and executing releases. Designed for both direct use by release managers and programmatic use by Claude Code during collaborative release sessions.

## Core Mission

Provide **deterministic operations** for the complex reality of cherry-picking releases:
- **Easy cherries**: Automate the straightforward cases that can be safely applied
- **Conflict analysis**: When cherry-picks fail, provide structured analysis of resolution paths
- **Dependency tracking**: Map SHA dependencies and understand the chain of required changes
- **State management**: Keep track of progress, what's been attempted, what worked, what failed
- **Resolution guidance**: Help determine if a PR is cherry-pickable or requires branch merging
- **Sanity preservation**: Maintain clear context when dealing with complex, multi-step resolution workflows

## Assumptions About Repository & Workflow

### Superset Git Workflow (Critical Assumptions)
- **Squash and merge ONLY**: Every PR becomes exactly one SHA in master
- **No merge commits**: Clean linear history on master
- **No other merge flows**: No rebase merging, no merge commits, no exceptions
- **One SHA per PR**: Deterministic mapping between PR number and master SHA

### Versioning Strategy (Semantic Versioning)
- **Major** (5.0): Point-in-time announcements, few per year, breaking changes allowed
- **Minor** (4.2): New features, always cut from master at specific point, has dedicated release branch
- **Patch** (4.2.3): Bug fixes and security patches ONLY, no features ever
- **Release Candidates** (4.2.0-rc1): Pre-release testing

### Branch Structure & Merge-base Reality
- **master**: Main development branch, linear history
- **Release branches**: `4.0`, `4.1`, `4.2`, `5.0` (one per minor version)
- **Different merge-bases**: Each minor cut from master at different points
  - `4.1` cut from master at SHA `aaa111...`
  - `4.2` cut from master at SHA `bbb222...` (later than 4.1)
  - `4.3` will be cut from master at SHA `ccc333...` (later than 4.2)
- **Tags**: Patch versions and RCs are tags on release branches (e.g., `4.2.3`, `4.2.0-rc1`)

### PR Labeling & Cherry-pick Strategy
**Labels Indicate Target Releases**:
- PR #12345 with labels `4.2`, `4.1` → cherry-pick SHA `abc123...` into both branches
- PR #12346 with label `4.2` only → cherry-pick SHA `def456...` into 4.2 branch
- Labels represent "I want this specific SHA in these releases"

**Merge-base Implications for Cherry-picking**:
- **Forward cherry-pick**: SHA from later master onto earlier release branch (common)
  - PR merged to master after 4.2 branch cut → cherry-pick into 4.2 branch
- **Backward cherry-pick**: SHA from earlier master onto later release branch (rare)
  - PR merged to master before 4.3 branch cut → cherry-pick into 4.3 branch
- **Cross-branch**: Same SHA may need different resolution strategies per branch
  - SHA applies cleanly to 4.2, conflicts with 4.1 (different codebase states)

### Release Workflow & Challenges
- **Minor-oriented**: "Working on baking the 4.2.3 release"
- **Branch-based**: Cherry-pick from master to release branch (e.g., `4.2`)
- **Tag-based**: Create tags for specific patch versions on release branches

**Cherry-pick Complexity Reality**:
- **Easy cases**: SHA applies cleanly to release branch → automated cherry-pick
- **Merge conflicts**: SHA conflicts with release branch state → needs resolution analysis
- **Dependency chains**: SHA assumes other SHAs were applied but they're missing from release branch
- **Large refactors**: Single SHA with massive changes → may conflict across many files
- **Context drift**: SHA written against different merge-base than release branch
- **Cross-branch variance**: Same SHA behaves differently on 4.1 vs 4.2 due to different merge-bases

**Workflow Advantages from Squash-Only**:
- **Predictable operations**: Always cherry-picking single, specific SHAs
- **Clear traceability**: PR number → SHA → cherry-pick target
- **Deterministic**: Same SHA + same target branch = same result every time
- **API integration**: GitHub API provides clean PR → label → SHA mapping
- **No merge complexity**: Never dealing with merge commit trees or multiple parents

## Release Branch Data Structure

### Core Concept: One YAML per Minor Release Branch

A release branch file (e.g., `5.0.yml`) represents the **complete state** of a minor release:
- **Base SHA**: The merge-base where this minor was cut from master
- **PR List**: All PRs labeled for this release (synced from GitHub)
- **Micro Releases**: Historical patch versions (tags) with their SHAs
- **Pending PRs**: What still needs to be cherry-picked for next micro

### Critical Elements

**1. Base SHA (Merge-base)**
- The SHA where this minor branch was cut from master
- **Critical for dependency analysis**: Determines which master SHAs are "before" or "after" branch cut
- **Conflict prediction**: SHAs after merge-base more likely to conflict

**2. PR Label Tracking**
- PRs labeled with `v5.0`, `v5.1`, etc.
- **Dynamic list**: Labels can change over time
- **Sync command**: `cherrytree sync 5.0` updates from GitHub API

**3. Release State Tracking**
- **Released PRs**: Already in some micro version
- **Pending PRs**: Labeled for release but not yet cherry-picked
- **Status command**: `cherrytree status 5.0` shows what needs work

## Release Branch YAML Structure

```yaml
# 5.0.yml - Complete state of 5.0.x minor release branch
release_branch:
  # Branch Identity
  minor_version: "5.0"
  branch_name: "5.0"

  # CRITICAL: Merge-base SHA where this branch was cut from master
  base_sha: "a1b2c3d4..."  # The point where 5.0 diverged from master
  base_date: "2024-08-15T10:30:00Z"  # When branch was cut

  # All PRs labeled for this release (synced from GitHub)
  labeled_prs:
    - pr_number: 12345
      title: "Fix dashboard loading bug"
      labels: ["v5.0", "bug-fix"]
      master_sha: "e5f6g7h8..."  # SHA of this PR in master
      author: "developer@superset.org"
      merged_date: "2024-09-01T14:20:00Z"
      status: "pending"  # pending | released | skipped | conflict

    - pr_number: 12346
      title: "Add new chart type"
      labels: ["v5.0", "feature"]
      master_sha: "i9j0k1l2..."
      author: "contributor@superset.org"
      merged_date: "2024-09-03T09:15:00Z"
      status: "released"  # Already in 5.0.1
      released_in: "5.0.1"

    - pr_number: 12347
      title: "Security patch for authentication"
      labels: ["v5.0", "security"]
      master_sha: "m3n4o5p6..."
      author: "security@superset.org"
      merged_date: "2024-09-10T16:45:00Z"
      status: "pending"  # Needs to go in next micro

  # Historical micro releases (tags on this branch)
  micro_releases:
    - version: "5.0.0"
      tag_sha: "q7r8s9t0..."  # SHA of 5.0.0 tag on 5.0 branch
      release_date: "2024-08-20T12:00:00Z"
      included_prs: []  # Initial release, no cherry-picks

    - version: "5.0.1"
      tag_sha: "u1v2w3x4..."  # SHA of 5.0.1 tag on 5.0 branch
      release_date: "2024-09-05T15:30:00Z"
      included_prs: [12346]  # PRs cherry-picked into this micro
      cherry_pick_shas:  # SHAs created by cherry-picking (different from master SHAs)
        - master_sha: "i9j0k1l2..."  # Original SHA in master
          branch_sha: "y5z6a7b8..."  # New SHA created on 5.0 branch
          pr_number: 12346

  # Current state analysis
  status:
    latest_micro: "5.0.1"
    pending_prs: [12345, 12347]  # PRs labeled but not yet released
    next_micro_candidate: "5.0.2"

  # Metadata
  last_synced: "2024-09-15T10:00:00Z"  # When we last ran `cherrytree sync 5.0`
  synced_from_repo: "apache/superset"

  # Analysis cache (computed by cherrytree)
  analysis:
    total_labeled_prs: 3
    released_prs: 1
    pending_prs: 2
    conflicts_detected: []  # Will be populated by conflict analysis
```

## Design Decisions

### 1. YAML Over Database
- **Versioned**: Release plans live in git alongside code
- **Reviewable**: PRs can modify release plans with peer review
- **Portable**: Plans can be shared, backed up, and audited
- **Declarative**: Represents desired state, not just current state

### 2. Minor-Oriented Atomicity
- Matches Superset workflow: "working on 4.2.3 release"
- One file per minor version reduces conflicts between teams
- Supports incremental planning across multiple patch versions
- Clear ownership and responsibility boundaries

### 3. Claude Code Integration Points
- **Structured Data**: YAML plans provide clear data structure for Claude to work with
- **Command Interface**: CLI provides atomic operations Claude can execute systematically
- **Status Tracking**: Commands report clear success/failure states
- **Context Preservation**: YAML maintains context between Claude sessions

### 4. Deterministic Operations for Conflict Resolution

## The `cherrytree sync` Command Design

**Purpose**: Build comprehensive release branch state by collecting all data from GitHub API and git.

**Command Signature**:
```bash
cherrytree sync <minor_version> [options]

# Examples:
cherrytree sync 5.0 --repo apache/superset
cherrytree sync 5.1 --repo apache/superset --output releases/
cherrytree sync 4.2 --incremental  # Only update changed data
```

### Data Collection Sources

**1. GitHub API Collection**:
```bash
# What sync collects from GitHub:
# - All PRs labeled with "v5.0"
# - PR metadata (title, author, merged_date, labels)
# - Master SHA for each PR (from merge commit)
# - PR status and current labels
```

**2. Git Repository Collection**:
```bash
# What sync collects from git:
# - Release branch merge-base SHA with master
# - All tags on release branch (5.0.0, 5.0.1, etc.)
# - SHA of each tag
# - Current branch HEAD SHA
# - Cherry-pick SHAs (different from master SHAs)
```

### Sync Algorithm

**Phase 1: Repository Analysis**
1. **Find merge-base**: `git merge-base master 5.0` → base SHA where branch diverged
2. **List release tags**: `git tag -l "5.0.*"` → all micro versions
3. **Get tag SHAs**: `git rev-list -n 1 5.0.1` → SHA of each tag
4. **Branch validation**: Confirm release branch exists and is up-to-date

**Phase 2: GitHub API Collection**
1. **Query labeled PRs**: Find all PRs with label `v5.0`
2. **Get PR metadata**: Title, author, merged_date, all labels
3. **Extract master SHAs**: Each PR's squash-merge SHA in master
4. **Merge date validation**: Ensure PR was merged after branch cut

**Phase 3: Cherry-pick Analysis**
1. **Compare SHAs**: Which master SHAs are already in release branch
2. **Map cherry-picks**: Match master SHA to branch SHA for applied PRs
3. **Identify pending**: Which labeled PRs aren't in any micro release yet
4. **Status classification**: pending | released | skipped | conflict

**Phase 4: YAML Construction**
1. **Build complete state**: Populate all sections of release_branch YAML
2. **Preserve history**: Keep existing micro_releases data
3. **Update metadata**: last_synced, analysis cache, etc.
4. **Write atomically**: Create temp file, then rename to avoid corruption

### Output Structure

**File Location**: `releases/5.0.yml` (configurable with --output)

**Incremental Updates**:
- Preserve existing `micro_releases` history
- Update `labeled_prs` with latest GitHub state
- Recalculate `status` section
- Update analysis cache

### Detailed Git Commands Executed

**Repository Analysis Phase**:
```bash
# 1. Find merge-base (critical for dependency analysis)
git merge-base master 5.0
# → a1b2c3d4ef56... (base SHA where 5.0 diverged)

# 2. Get branch cut date
git show --format="%ci" a1b2c3d4ef56
# → 2024-08-15 10:30:00 -0700

# 3. List all micro release tags
git tag -l "5.0.*" --sort=-version:refname
# → 5.0.2, 5.0.1, 5.0.0

# 4. Get SHA for each tag
git rev-list -n 1 5.0.0  # → q7r8s9t0...
git rev-list -n 1 5.0.1  # → u1v2w3x4...
git rev-list -n 1 5.0.2  # → y5z6a7b8...

# 5. Get current branch HEAD
git rev-parse 5.0  # → current tip of 5.0 branch
```

**GitHub API Queries**:
```bash
# 1. Find all PRs with v5.0 label
GET /repos/apache/superset/pulls?state=closed&labels=v5.0&per_page=100

# 2. For each PR, get merge SHA from master
GET /repos/apache/superset/pulls/{pr_number}
# Extract: merge_commit_sha (the squash-merge SHA in master)

# 3. Get PR labels and metadata
# Extract: title, user.login, merged_at, labels[].name
```

**Cherry-pick Mapping Analysis**:
```bash
# 1. For each master SHA, check if it exists in release branch
git merge-base --is-ancestor {master_sha} 5.0
# Exit code 0 = already in branch, 1 = not in branch

# 2. For applied PRs, find the cherry-pick SHA on release branch
git log 5.0 --oneline --grep="cherry picked from commit {master_sha}"
# → Maps master SHA to branch SHA

# 3. Determine which micro release contains each PR
git tag --contains {branch_sha} --list "5.0.*"
# → Shows which tag first contained this cherry-pick
```

### Command Examples

**Initial Sync** (creates new file):
```bash
cherrytree sync 5.0 --repo apache/superset
# → Executing 25+ git commands and 5+ GitHub API calls
# → Creates releases/5.0.yml with complete state:
#     - Base SHA: a1b2c3d4 (2024-08-15)
#     - Found 15 PRs labeled v5.0
#     - Latest micro: 5.0.1 (includes 3 PRs)
#     - Pending PRs: 12 (need cherry-picking)
#     - Cherry-pick mappings: 3 master→branch SHA pairs
```

**Incremental Sync** (updates existing):
```bash
cherrytree sync 5.0 --incremental
# → Only queries GitHub API for PR changes
# → Only checks git for new tags since last sync
# → Updated releases/5.0.yml:
#     - Found 3 new PRs labeled v5.0
#     - No new micro releases detected
#     - Pending PRs: 15 (3 added, 0 resolved)
```

**Debug Mode**:
```bash
cherrytree sync 5.0 --verbose --dry-run
# → Shows exactly what git commands would be executed
# → Shows GitHub API calls that would be made
# → Previews YAML structure without writing file
```

## The `cherrytree status` Command

**Purpose**: Show current release branch state in a clean, readable format.

**Command Signature**:
```bash
cherrytree status <minor_version> [options]

# Examples:
cherrytree status 5.0
cherrytree status 5.0 --format table  # Default
cherrytree status 5.0 --format json   # For Claude/scripts
```

### Status Output Design

**Release Overview Section**:
```
Release Branch: 5.0
├── Base SHA: a1b2c3d4 (2024-08-15)
├── Latest Micro: 5.0.1 (2024-09-05)
├── Release Candidate: 5.0.2-rc1 (2024-09-12) [if exists]
└── Branch HEAD: y5z6a7b8

Last Synced: 2024-09-15 10:00:00 (2 hours ago)
```

**PR List to Merge Table**:
```
┌────────┬──────────────────────────┬─────────────┬────────────┬──────────┐
│ PR     │ Title                    │ Author      │ Master SHA │ Status   │
├────────┼──────────────────────────┼─────────────┼────────────┼──────────┤
│ #12345 │ Fix dashboard loading    │ dev@super.. │ e5f6g7h8   │ Pending  │
│ #12347 │ Security auth patch      │ sec@super.. │ m3n4o5p6   │ Pending  │
│ #12348 │ Chart rendering fix      │ ui@super..  │ i9j0k1l2   │ Conflict │
│ #12350 │ Add new visualization    │ viz@super.. │ q1w2e3r4   │ Pending  │
└────────┴──────────────────────────┴─────────────┴────────────┴──────────┘

Summary: 4 PRs labeled for 5.0 → 3 pending, 1 conflict detected
```

## The `cherrytree next` Command

**Purpose**: Determine the next SHA to cherry-pick based on master commit order.

**Command Signature**:
```bash
cherrytree next <minor_version> [options]

# Examples:
cherrytree next 5.0
cherrytree next 5.0 --format json
cherrytree next 5.0 --skip-conflicts  # Skip problematic PRs
```

### Next SHA Algorithm

**Master Chronological Order**:
1. **Load release YAML**: Get pending PRs and their master SHAs
2. **Sort by master order**: `git log master --oneline --format="%H"`
3. **Find earliest pending**: First pending SHA in master chronological order
4. **Conflict check**: Verify SHA can be cherry-picked cleanly
5. **Return recommendation**: SHA + metadata for cherry-pick

**Example Output**:
```bash
cherrytree next 5.0
# → Next SHA: e5f6g7h8
# → PR #12345: "Fix dashboard loading bug"
# → Author: developer@superset.org
# → Merged: 2024-09-01 (14 days ago)
# → Applies cleanly: ✅ Yes
# → Command: git cherry-pick e5f6g7h8
```

**Conflict Handling**:
```bash
cherrytree next 5.0
# → Next SHA: i9j0k1l2
# → PR #12348: "Chart rendering fix"
# → Applies cleanly: ❌ Conflicts detected
# → Suggestion: Run 'cherrytree conflict analyze 12348' for resolution options
# → Skip: Use --skip-conflicts to get next clean SHA
```

**JSON Format** (for Claude integration):
```json
{
  "next_sha": "e5f6g7h8",
  "pr_number": 12345,
  "title": "Fix dashboard loading bug",
  "author": "developer@superset.org",
  "merged_date": "2024-09-01T14:20:00Z",
  "applies_cleanly": true,
  "cherry_pick_command": "git cherry-pick e5f6g7h8",
  "position_in_queue": 1,
  "total_pending": 4
}
```

## Configuration & Context Management

**Cherrytree Context System**: Using Typer's built-in context management for global parameters.

### Global Configuration

**Repository Path Configuration**:
```bash
# Set local git workbench directory (required)
cherrytree config set-repo /path/to/superset
# → Stored in ~/.cherrytree/config.yml

# GitHub repository defaults to apache/superset
# Only set if using a fork or different repo
cherrytree config set-github your-org/superset-fork

# View current configuration
cherrytree config show
# → Repository: /path/to/superset
# → GitHub: apache/superset (default)
# → GitHub Auth: ✅ Authenticated via gh CLI
```

**Per-Command Override**:
```bash
# Override repo path for specific commands
cherrytree status 5.0 --repo /different/path/to/superset
cherrytree sync 5.0 --repo /different/path --github-repo apache/superset

# Context is automatically available to all commands
cherrytree next 5.0  # Uses configured repo path
```

### Tool Integration Strategy

**Git Operations**: Use system git client via subprocess (GitPython wrapper)
```python
import subprocess
from pathlib import Path

def git_command(args: list, repo_path: Path) -> subprocess.CompletedProcess:
    """Execute git command in specified repository."""
    return subprocess.run(
        ["git"] + args,
        cwd=repo_path,
        capture_output=True,
        text=True,
        check=True
    )

# Usage in cherrytree commands:
result = git_command(["merge-base", "master", "5.0"], ctx.repo_path)
merge_base = result.stdout.strip()
```

**GitHub Integration**: Use official GitHub CLI (gh) + subprocess
```python
def gh_api(endpoint: str, repo: str) -> dict:
    """Query GitHub API using gh CLI."""
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/{endpoint}"],
        capture_output=True,
        text=True,
        check=True
    )
    return json.loads(result.stdout)

# Usage:
pulls = gh_api("pulls?state=closed&labels=v5.0", ctx.github_repo)
```

**Benefits of Official Tools**:
- **Git**: No library dependencies, uses system git (same behavior as manual commands)
- **GitHub CLI**: Leverages user's existing `gh auth`, handles rate limiting, follows GitHub best practices
- **Consistency**: Same tools humans use manually
- **Authentication**: Uses existing user auth setup (no token management in cherrytree)

**Configuration File Structure** (`~/.cherrytree/config.yml`):
```yaml
default:
  repo_path: "/Users/developer/code/superset"
  github_repo: null  # Defaults to "apache/superset" when null
  releases_dir: "releases"  # Where to store YAML files

github:
  default_repo: "apache/superset"  # Built-in default
  authenticated: true
  auth_method: "gh_cli"  # Uses gh CLI authentication

preferences:
  default_format: "table"  # table | json
  conflict_strategy: "prompt"  # prompt | skip | analyze
  sync_frequency: "auto"  # auto | manual
```

**Default Behavior** (zero configuration):
```bash
# Works immediately if gh CLI is authenticated
cherrytree sync 5.0 --repo /path/to/superset
# → Uses apache/superset automatically

# Set local path once, never think about GitHub repo again
cherrytree config set-repo /path/to/superset
cherrytree sync 5.0
# → Uses /path/to/superset + apache/superset (automatic)
```

### Context-Aware Command Examples

**Minimal Setup** (most users):
```bash
# Only need to set local repo path once
cd /path/to/superset
cherrytree config set-repo $(pwd)

# GitHub repo defaults to apache/superset automatically
cherrytree config show
# → Repository: /path/to/superset ✅
# → GitHub: apache/superset ✅ (default)
# → GitHub Auth: ✅ (via gh CLI)
```

**Fork/Custom Repo Setup** (when needed):
```bash
# Set both local path and custom GitHub repo
cherrytree config set-repo /path/to/my-superset-fork
cherrytree config set-github myorg/superset-fork

# Or override per-command when testing
cherrytree sync 5.0 --github-repo myorg/superset-fork
```

**Daily Usage** (no path repetition needed):
```bash
# All commands use configured context automatically
ct sync 5.0          # Uses /path/to/superset + apache/superset
ct status 5.0        # Uses same context
ct next 5.0          # Uses same context

# Both ct and cherrytree work identically
cherrytree sync 5.0  # Same as ct sync 5.0

# Override when needed
ct status 5.0 --repo /tmp/superset-fork
```

### Integration with Release Workflow

**Human Usage** (typical Superset maintainer):
```bash
# One-time setup (apache/superset assumed)
cherrytree config set-repo /path/to/superset

# Daily workflow - no configuration needed
cherrytree status 5.0        # Uses /path/to/superset + apache/superset
cherrytree next 5.0          # Context flows automatically
# → Next SHA: e5f6g7h8

# Git operations in same directory
git cherry-pick e5f6g7h8

# Update state
cherrytree sync 5.0 --incremental
```

**Claude Usage**:
```bash
# Claude can read user's configuration
cherrytree config show --format json
# → Understands repo path, GitHub repo, preferences

# All Claude commands automatically use correct context
cherrytree status 5.0 --format json
cherrytree next 5.0 --format json
```

## Goals

### Short Term - Foundation
1. **Release Branch YAML Schema**: Complete state tracking with merge-base
2. **Core Commands**: `sync`, `status`, `cherry-pick try/batch`, `conflict analyze`
3. **GitHub Integration**: Sync PR labels and metadata automatically
4. **Git Integration**: Track branch state, tags, and cherry-pick results

### Medium Term - Intelligence
1. **Dependency Analysis**: Understand which PRs depend on others not in release
2. **Conflict Prediction**: Analyze merge-base differences to predict conflicts
3. **Resolution Guidance**: Structured analysis of options for difficult cherry-picks
4. **Batch Operations**: Handle multiple cherry-picks efficiently

### Long Term - Workflow Support
1. **Cross-branch Analysis**: Understand how same PR behaves on different release branches
2. **Historical Patterns**: Learn from past successful/failed cherry-pick patterns
3. **Release Planning**: Help plan micro releases based on PR urgency and risk
4. **Integration Ecosystem**: Hooks for CI/CD, notifications, and release automation

## Typical Workflow Example

**Release Manager preparing 5.0.2**:
```bash
# 1. Sync latest state from GitHub and git
ct minor sync 5.0
# → Updates 5.0.yml: found 3 new PRs labeled v5.0, latest micro is 5.0.1

# 2. Check what needs to be released
ct minor status 5.0
# → Shows: 4 pending PRs labeled for 5.0, suggests next micro: 5.0.2

# 3. Get next cherry-pick recommendation
ct minor next 5.0 -v
# → Next SHA: e5f6g7h8, PR #12345: "Fix dashboard loading bug"
# → Command: git cherry-pick -x e5f6g7h8

# 4. Execute the cherry-pick
git cherry-pick -x e5f6g7h8

# 5. Analyze problematic ones if needed
ct conflict analyze 12347 --branch 5.0
# → Shows merge conflicts in 3 files, suggests manual resolution

# 6. Get current state for next steps
ct minor status 5.0 --format json
# → Structured output for Claude to understand current state
```

**Claude assisting with complex resolution**:
- Reads `5.0.yml` to understand current state
- Uses `ct conflict analyze` to understand specific conflicts
- Helps decide between manual resolution, skipping PR, or including dependencies
- Updates release plan based on decisions made together

## Success Metrics

- **Adoption**: Release managers prefer cherrytree over manual git commands
- **Reliability**: 95% of cherry-picks execute successfully without manual intervention
- **Collaboration**: Claude can effectively assist with releases using cherrytree commands
- **Maintainability**: YAML plans serve as effective documentation and audit trails

## Open Questions

1. **Multi-maintainer Coordination**: How do multiple release managers collaborate on the same plan?
2. **Rollback Strategy**: How do we handle partial failures and rollbacks in YAML state?
3. **Branch Divergence**: How do we handle cases where release branches diverge significantly?
4. **Claude Context**: How much release context should be embedded in YAML vs. discovered dynamically?
5. **Error Recovery**: What's the best way to resume failed cherry-pick operations?

## Current Status ✅ PRODUCTION READY

**Complete Commands**:
- **`ct minor sync 6.0`** - Complete state collection from GitHub + git
- **`ct minor status 6.0`** - Rich timeline + PR processing table with semantic version logic
- **`ct minor next 6.0`** - Get next SHA in chronological order (basic/verbose/JSON modes)
- **`ct micro status 6.0.0rc1`** - Show PRs included in specific micro releases
- **`ct config set-repo`** - One-time setup with smart defaults

**Production Features**:
- **8-digit SHAs**: Perfect balance of readability and uniqueness (75% space savings)
- **Clickable integration**: PR/commit links that open in GitHub
- **Semantic version logic**: Proper handling of version redirection
- **Cherry-pick best practices**: `-x` flag for commit traceability
- **Real-world tested**: Both legacy (4.0, 195 PRs) and active (6.0, 35 PRs) branches
- **Performance**: 30-second sync on enterprise-scale repositories
- **Human-Claude collaboration**: Shared YAML workspace + dual output formats

See **PROJECT.md** for complete implementation history and technical details.
